// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE.md file.

// +build ignore

package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

const (
	inputDir   = "public/"
	outputFile = "staticfs.go"
)

var mimeTypes = map[string]string{
	"css":  "text/css; charset=utf-8",
	"html": "text/html; charset=utf-8",
	"ico":  "image/x-icon",
	"js":   "application/javascript",
	"svg":  "image/svg+xml",
	"woff": "font/woff",
}

func main() {
	// Ensure that we are running the generator from the right directory.
	stat1, err1 := os.Stat(inputDir)
	stat2, err2 := os.Stat(outputFile)
	if err1 != nil || err2 != nil || !stat1.IsDir() || stat2.IsDir() {
		fmt.Fprintln(os.Stderr, fmt.Sprintf(""+
			"Usage: go run staticfs_gen.go\n\n"+
			"Must be run from root of the playground repository.\n"+
			"This archives %s and outputs %s.", inputDir, outputFile))
		os.Exit(1)
	}

	// Create map of all static files.
	m := make(map[string][]byte)
	err := filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() || !knownExtension(path) {
			return nil
		}
		b, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}
		path = strings.TrimPrefix(path, inputDir)
		m[path] = b
		return nil
	})
	if err != nil {
		log.Fatalf("Walk error: %v", err)
	}

	// Generate and format the static source file.
	template := `
		// Copyright 2017 The Go Authors. All rights reserved.
		// Use of this source code is governed by a BSD-style
		// license that can be found in the LICENSE.md file.

		// Code generated by staticfs_gen.go with %s. DO NOT EDIT.

		package main

		import (
			"compress/gzip"
			"encoding/base64"
			"io/ioutil"
			"strings"
		)

		// mimeTypes is a mapping from file extensions to MIME types.
		var mimeTypes = map[string]string{%s}

		// mimeFromPath returns the MIME type based on the file extension in the path.
		func mimeFromPath(p string) string {
			if i := strings.LastIndexByte(p, '.'); i >= 0 {
				return mimeTypes[p[i+1:]]
			}
			return ""
		}

		// staticFS is a mapping from file paths to the contents of a file.
		var staticFS = map[string][]byte {%s}

		func decompressBase64(s string) []byte {
			r := strings.NewReader(s)
			rx := base64.NewDecoder(base64.StdEncoding, r)
			rz, _ := gzip.NewReader(rx)
			b, _ := ioutil.ReadAll(rz)
			return b
		}`
	gen := fmt.Sprintf(template, runtime.Version(), formatMIMEs(mimeTypes), formatFiles(m))
	out, err := format.Source([]byte(gen))
	if err != nil {
		log.Fatalf("format.Source error: %v", err)
	}

	// Write the source file.
	if err := ioutil.WriteFile(outputFile, out, 0644); err != nil {
		log.Fatalf("ioutil.WriteFile error: %v", err)
	}
}

func knownExtension(p string) bool {
	i := strings.LastIndexByte(p, '.')
	return i >= 0 && mimeTypes[p[i+1:]] != ""
}

func formatFiles(m map[string][]byte) string {
	var ks, ss []string
	for k := range m {
		ks = append(ks, k)
	}
	sort.Strings(ks)
	for _, k := range ks {
		// Gzip compress the gob data.
		bz := new(bytes.Buffer)
		wz, _ := gzip.NewWriterLevel(bz, gzip.BestCompression)
		if _, err := wz.Write(m[k]); err != nil {
			log.Fatalf("gzip.Write error: %v", err)
		}
		if err := wz.Close(); err != nil {
			log.Fatalf("gzip.Close error: %v", err)
		}

		// Base64 encode the compressed data.
		bx := new(bytes.Buffer)
		wx := base64.NewEncoder(base64.StdEncoding, bx)
		if _, err := wx.Write(bz.Bytes()); err != nil {
			log.Fatalf("base64.Write error: %v", err)
		}
		if err := wx.Close(); err != nil {
			log.Fatalf("base64.Close error: %v", err)
		}

		ss = append(ss, fmt.Sprintf("%q:decompressBase64(%q),\n", k, bx.Bytes()))
	}
	return "\n" + strings.Join(ss, "")
}

func formatMIMEs(m map[string]string) string {
	var ks, ss []string
	for k := range m {
		ks = append(ks, k)
	}
	sort.Strings(ks)
	for _, k := range ks {
		ss = append(ss, fmt.Sprintf("%q:%q,\n", k, m[k]))
	}
	return "\n" + strings.Join(ss, "")
}
